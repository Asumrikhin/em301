


Эконометрика в R
========================================================


### Что это за текст?

На 3-м курсе факультета экономики [вышки](http://www.hse.ru) есть Самая Важная дисциплина. Это --- Эконометрика. А этот текст --- моя рабочая тетрадь R, в которой я готовлю семинары. 

Страница курса, [https://github.com/bdemeshev/em301/wiki](https://github.com/bdemeshev/em301/wiki) --- там размещены все наборы данных и другие материалы по курсу.

Если есть вопросы --- пишите на boris.demeshev@gmail.com.

Борис Демешев

### Базовые команды операционной системы

Linux/MacOs
1. Узнать текущую рабочую директорию:

```r
pwd
```

2. Сменить директорию:

```r
cd target_folder
```

Не забывайте, что в командной строке работает <Tab> и клавиши вверх, вниз.
3. Посмотреть список файлов в текущей директории:

```r
ls
```

4. Создать папку

```r
mkdir the_new_folder
```

5. Запустить скрипт R

```r
Rscript file_to_run.R
```



Windows:
1. Узнать текущую рабочую директорию:

```r
cd
```

2. Сменить директорию:

```r
cd target_folder
```

Не забывайте, что в командной строке работает <Tab> и клавиши вверх, вниз.
3. Посмотреть список файлов в текущей директории:

```r
dir
```

4. Создать папку

```r
mkdir the_new_folder
```

5. Запустить скрипт R

```r
C:\path_to_R\Rscript file_to_run.R
```

По умолчанию в Windows для запуска программы нужно указывать её полный путь. Чтобы этого не делать каждый раз, а писать коротко `Rscript file_to_run.R`, нужно внести путь к папке с R в переменную $PATH. Для этого...



### Навигация по папкам:

1. Узнать текущую рабочую директорию:

```r
getwd()
```

```
## [1] "/home/boris/science/econometrix/em301"
```

2. Установить рабочую директорию:

```r
setwd("/home/boris/science/emetrix/em301")
```

Не забывайтие, что в R-studio работает <Tab>!
3. Посмотреть список файлов в текущей директории:

```r
dir()
```

```
##  [1] "datasets"                 "em301_grade_system.txt"  
##  [3] "em301_grade_system.txt~"  "em301_ht1.txt"           
##  [5] "em301_r.html"             "em301_r.md"              
##  [7] "em301_r.Rmd"              "em301_theory.aux"        
##  [9] "em301_theory.fdb_latexmk" "em301_theory.fls"        
## [11] "em301_theory.log"         "em301_theory.out"        
## [13] "em301_theory.pdf"         "em301_theory.pyg"        
## [15] "em301_theory.synctex.gz"  "em301_theory.tdo"        
## [17] "em301_theory.tex"         "figure"                  
## [19] "hse_notes"                "mamontov_style"          
## [21] "NA"                       "README.md"               
## [23] "r_packages.txt"           "video_fun"               
## [25] "working_plans.txt"        "working_plans.txt~"
```

Можно указать пролистываемую папку, например,

```r
dir("datasets")
```

```
## [1] "faithful_2011.txt" "p2011.zip"         "p2012.zip"
```

4. Создать папку

```r
dir.create("the_new_folder")
```

5. Сохранить историю набранных команд:

```r
savehistory("log_file.txt")
```

6. Запустить скрипт не выходя из R:

```r
source("script_to_run.R")
```

7. Выйти из R `quit()` или коротко `q()`

```r
q()
```

На дворе 21 век, тем не менее:
* Не используйте в именах папок русские буквы
* Не используйте в именах папок пробелы

### Получение справки

Справка по конкретной команде

```r
`?`(t.test)
```


Поиск нужной команды по ключевому слову

```r
`?`(`?`(anova))
```


А дальше имеет смысл искать в интернете. Имеет смысл гуглить по фразе "something I need in R". Если поиск не увенчался успехом, то тогда имеет смысл задать вопрос на одном из форумов: 
* [stats.stackexchange.com](http://stats.stackexchange.com) - по реализации статистических методов на R
* [stackoverflow.com](http://stackoverflow.com) - по программированию в целом



### Типы данных

Самый простой тип --- это векторы переменных одного типа.


```r
x = c(1.5, 2.4, 3.6)  # вектор из чисел
y = c("Аня", "Маша", "Ира", "Света")товых переменных
w = c("Да", "Да", "Не знаю", "Нет", "Не знаю")
z = c(TRUE, FALSE, TRUE)  # вектор логических значений
```


Среди чисел могут встретиться такие звери, как `NA`, `NaN` и `Inf`.
* `NA` означает "нет данных", так кодируют пропущенные наблюдения
* `NaN` означает "не число", как правило возникает в результате запрещенных арифметических операций
* `Inf` означает плюс бесконечность, некоторые команды абсолютно спокойно с ней работают

Например:

```r
x = 1/0
cat(x)
```

```
## Inf
```

```r
atan(x)  # аркангенс от плюс бесконечности легко считается
```

```
## [1] 1.571
```

```r
cat(x - 1e+05)  # чуть-чуть уменьшим бесконечность...
```

```
## Inf
```

```r
y = 0/0
cat(y)  # y не определён
```

```
## NaN
```

```r
atan(y)  # арктангенс от y тоже не определён
```

```
## [1] NaN
```


С отсутствующими наблюдениями `R` ничего поделать не может:

```r
x = c(4, 5, NA, 3, 4, 6)
cat(x/2)
```

```
## 2 2.5 NA 1.5 2 3
```




Текстовые можно легко преобразовать в *качественные*:

```r
w2 = factor(w)
```


У качественной переменной в отличие от текстовой ограничено множество значений. Если на некий вопрос люди отвечали только 'Да', 'Нет' или 'Не знаю', то это качественная переменная. Качественные данные занимают в памяти комьютера меньше места и для них есть множество специальных функций. Частный случай, *качественные порядковые* переменные

```r
stud = factor(c("Школьник", "Бакалавр", "Бакалавр", 
    "Школьник", "Магистр", "Школьник", "Магистр", 
    "Бакалавр"), levels = c("Школьник", "Бакалавр", 
    "Магистр"), ordered = TRUE)
stud
```

```
## [1] Школьник Бакалавр Бакалавр Школьник Магистр  Школьник Магистр  Бакалавр
## Levels: Школьник < Бакалавр < Магистр
```


Из векторов одинаковой длины и одного типа можно собрать матрицу:

rbind
cbind


Маленькая техническая подробность. На самом деле R хранит любую матрицу в виде вектора с дополнительной пометкой, атрибутом, о размере матрицы. 

Узнаём размер матрицы:

```r
dim(mat)
```

```
## Error: object 'mat' not found
```

Можно использовать и более длинную, но зато универсальную команду, подходяющую для всех атрибутов, `attr(mat,'dim')`.


Векторы одинаковой длины с данными разных типов можно собрать в таблицу данных *dataframe*

Создаём таблицу данных из отдельных переменных

```r
dm = data.frame(x, y, z)
```



Переменную `x` из таблицы данных `dm` можно вытащить с помощью `dm['x']` или, короче, `dm$x`.

Помимо переменных у таблицы с данными может быть куча атрибутов. Атрибут может нести любую вспомогательную информацию. Самым распространённый атрибут, имена переменных, `attr(dm,'names')`. В силу его распространённости для него есть короткая команда `names(dm)`.

Настоятельно рекомендую добавлять атрибут `var_labels` с более подробным описанием
переменных, подобно variable labels в Стате

```r
attr(dm, "var_labels") = c("Прожиточный минимум в 3042 году согласно исследованиям 2012 года", 
    "Просто какая-то переменная")
```


Чтобы узнать, что за объект перед нами, используем, `str()`

```r
str(stud)
```

```
##  Ord.factor w/ 3 levels "Школьник"<"Бакалавр"<..: 1 2 2 1 3 1 3 2
```


### Загрузка данных из STATA, SPSS, ...

Загрузка файла STATA

```r
library(foreign)
dm = read.dta("myfile.dta")
```

```
## Error: unable to open file: 'No such file or directory'
```


В качестве атрибутов сохраняются названия и описания переменных:

```r
attr(dm, "names")
```

```
## [1] "x" "y" "z"
```

```r
attr(dm, "var.labels")
```

```
## NULL
```


Вместо `attr(dm,'names')` можно писать коротко `names(dm)`. Атрибут `var.labels` используется реже, поэтому для него более короткой команды нет. (хм, а вдруг есть?)  

Чтобы посмотреть, что ещё оказалось в таблице с данными, можно использовать функцию `str(dm)`.





У количественных переменных можно посчитать матрицу выборочных корреляций и матрицу выборочных ковариаций

```r
cov(x)
```

```
## Error: supply both 'x' and 'y' or a matrix-like 'x'
```

```r
cor(x)
```

```
## Error: supply both 'x' and 'y' or a matrix-like 'x'
```


Можно посчитать выборочную ковариацию и корреляцию между двумя конкретными векторами

```r
cov(x, y)
```

```
## Error: incompatible dimensions
```

```r
cor(x, y)
```

```
## Error: incompatible dimensions
```


Кстати, из этого следует интересная мысль (?) обозначать cor, cov в лекциях по теории вероятностей. Не corr.



### Рисование графиков

> В выборке из ста муравьёв и одного кита средняя масса муравья может превышать тонну.




Можно рисовать графики встроенными средствами R, но для более качественных графиков мы будем использовать пакет `ggplot2`

```r
library(ggplot2)
```



Самые часто употребимые типы 


```r
plot(cars)
```

![plot of chunk unnamed-chunk-35](https://github.com/bdemeshev/em301/raw/master/figure/unnamed-chunk-35.png) 




### Оценка простой модели регрессии

Линейная регрессия оценивается командой:

```r
m0 <- lm(y ~ x + z, data = dm)
```

```
## Error: 0 (non-NA) cases
```


Модель `m0` --- это список из разных оценённых показателей.

Отчёт о результатах

```r
summary(m0)
```

```
## Error: object 'm0' not found
```


Из списка результатов для дальнейшей работы можно раздобыть коэффициенты, вектор остатков, вектор оценённых зависимых переменных и многое другое:

```r
coef(res)
```

```
## Error: object 'res' not found
```

```r
residuals(res)
```

```
## Error: object 'res' not found
```

```r
fitted.values(res)
```

```
## Error: object 'res' not found
```


Посмотреть, что ещё есть в списке легко:

```r
names(res)
```

```
## Error: object 'res' not found
```

Можно также использовать `str(res)`.

Оценка ковариационной матрицы считается дополнительно,

```r
vcov(res)
```

```
## Error: object 'res' not found
```




Между эконометристами ведутся священные войны по поводу того, что такое RSS. Одни считают,
что RSS --- это residual sum of squares, $RSS=\sum (y_i-\hat{y}_i)^2$. Другие 
считают, что это regression sum of squares, $RSS=\sum (\hat{y}_i-\bar{y})^2$. Поисковик google на выражение residual sum of squares выдает в три раза больше ссылок. 
Поэтому в данном курсе мы так и будем считать.


Можно раздобыть RSS (residual sum of squares).


```r
rss = deviance(res)
```

```
## Error: object 'res' not found
```


Естественно, RSS можно посчитать и ручками:

```r
rss_by_hand = sum(residuals(res)^2)
```

```
## Error: object 'res' not found
```







### Установка пакетов в R
Для установки пакетов нужно соединение с интернетом. Установим, например, пакет `vcd` для мозаичных графиков

```r
install.packages("vcd")
```

После установки пакета на компьютер, его можно загрузить

```r
library(vcd)
```

```
## Loading required package: MASS
```

```
## Loading required package: grid
```

```
## Loading required package: colorspace
```

И использовать...



### MLE in R

В реальности редко приходится вручную максимизировать функцию правдоподобия. Для популярных моделей в R уже есть готовые функции. Для замысловатых экзотических моделей ML будет "нехорошо себя вести". Например, он будет крутиться вокруг локального экстремума, не сходится вообще или требовать огромного времени на численный подсчёт тройных интегралов. В экзотических моделях скорее всего имеет смысл воспользоваться MCMC. 


Однако в учебных целях написать ML руками просто обязательно. Чтобы пользоваться калькулятором с чистой совестью, нужно уметь умножать в столбик!


Хорошие мелочи: 

* Функцию называть mlog, чтобы подчеркнуть, что это минус функция правдоподобия. 
* Чтобы это было видно в ней самой она должна выглядеть примерно так:


```r
mlog <- function(params, data) {
    # это функция вычисляет функцию правдоподобия со знаком минус
    logl = tra - ta - ta
    return(-logl)
}
```



### Схожие сюжеты нужно рассказывать рядом

logit/probit
SVM
RandomForest


Ridge Regression
Lasso



На графиках показать:

OLS --- Lowess
Logit/Probit --- сглаживание вероятности (показать сами данные точечками)
Оценка pdf с помощью ML --- Kernel estimation, Гистограмма (сами данные --- черточками)

OLS --- quantile regression

Метод главных компонент (corr, cov)
Факторный анализ



### Временные ряды

Раскрываем мировой заговор! Временные ряды --- это вовсе не ряды! Это последовательности! 

Последовательность: $x_1$, $x_2$, $x_3$, ....


Ряд: $x_1+x_2+x_3+\ldots$


### Bootstrap



### SEM



### Logit/probit


#### Классический подход к logit/probit


#### Байесовский подход к logit/probit

#### SVM

#### RandomForest





### MCMC

Можно применять метод MCMC используя только сам R. Но это не самый продуктивный способ, для этого существенно более быстрые специальные пакеты. Мы будем использовать [JAGS](http://mcmc-jags.sourceforge.net/). Это отдельный пакет, в котором есть свой язык описания моделей, и его, в принципе, можно использовать отдельно от R. Для вызова JAGS из R, нужно установить дополнительный пакет, `rjags`. Делается это командой `install.packages('rjags')` из R.



```r
library(rjags)
```

```
## Loading required package: coda
```

```
## Loading required package: lattice
```

```
## linking to JAGS 3.2.0
```

```
## module basemod loaded
```

```
## module bugs loaded
```




Байесовский подход за 15 минут.

Мы предполагаем некое априорное распределение параметров $\theta$.

Мы предполагаем некую модель, как устроены наши данные.

Если модель проста, то применив формулу условной вероятности, можно получить апостериорное распределение параметров в явном виде.

Если модель сложна, то в явном виде апостериорное распределение получить не удаётся, но зато с помощью алгоритмов MCMC можно получить сгенерить выборку случайных величин из апостериорного распределения.


Пример 1. (одномерный с явными функциями) 

Изначально я верю, что ...

Получаем апостериорное распределение аналитически.

Посмотрим, как его получит JAGS

MCMC строит последовательность случайных величин, распределение которых стремится к искомому апостериорному распределению. ... Поэтому для описания апостериорного распределения мы игнорируем начало последовательности случайных величин. burn in

Как JAGS это сделал?







Пример 2. 

Происшествия на английских угольных шахтах

модель


Эта модель уже настолько сложна, что апостериорное распределение параметров в явном виде не выписывается!


Происшествия на английских угольных шахтах с JAGS:


Что делал JAGS за кадром...









Из кода видно, что нам не приходится выводить вручную условные распределения. На самом деле мы всего лишь описываем модель в дерева (направленного ациклического графа).

(картинка)


Из описания модели в виде графа можно получить условную функцию плотности параметра $\theta$ по теореме
$$
f(\theta|G-\theta) \sim f(\theta|parents(\theta))\cdot \prod_{a
\in children(\theta)}f(a|parents(a))
$$

Схематично JAGS поступает так:

* По теореме выясняет условное распределение каждого параметра $\theta$. 
* Если JAGS обнаружит сопряженность и стандартное распределение, то он будет их использовать при генерировании $\theta$. 
* Если JAGS не обнаружит сопряженных распределений, то он прибегнет к алгоритму Метрополиса для генерирования $\theta$. 


### maps


### Big data



Что делать когда объемы данных - большие и памяти не хватает...

* Установите правильные типы переменных
* Меньше ресурсов уходит на работу с матрицами, а не с таблицами данных (dataframe)
* Попробуйте пакет  [bigmemory](http://cran.r-project.org/web/packages/bigmemory/index.html)
* Купите больше памяти для компьютера
* Загружайте в ОЗУ только нужные столбцы/строки для анализа
* Делайте предварительный анализ на небольшой случайной выборке из вашего набора данных. Когда уже ясна полностью последовательность анализа, можно сделать его по всем данным на мощном компьютере.

[Источник](http://stackoverflow.com/questions/11715408)

### Пообсуждать с К.Ф.:

Зачем мы проверяем beta=0, если мы точно знаем, что это не так?

Что же всё таки делать с данными по генеральной совокупности?




